1. Mysql有什么数据引擎
>- `InnoDB`,支持行级锁、表级锁、事务、索引、独立表空间,`其他引擎均不支持事务`
>- `Myisam`，数据可进行压缩，采用表级锁，查询快，适用于：只读应用、
> 非事务应用（数据仓库、报表、日志数据）、空间类应用，会存储自增主键
>- `CVS`,所有列not null，不支持索引，数据可直接用Excel编辑
>- `Active`，以zlib对数据压缩，磁盘I/O更少，只支持insert、select
>只能在自增上创建索引，常用于日志采集
>- `Memory`，基于内存的引擎，数据都存在内存中
>- `Ferderated`,远程访问引擎，表结构在本地，数据在远程服务器
2. 事务的ACID是什么
>- 原子性 Atomicity，事务是每一次执行的都是原子操作
>- 一致性 Consistency，事务前后数据的完整性必须保持一致
>- 隔离性 Isolation,多个并发事务之间要相互隔离
>- 持久性 Durability,数据永久保存在数据库中
3. 隔离级别是什么
>- 未提交读(READ-UNCOMMITED),会产生脏读
>- 提交读(READ-COMMITED),解决脏读,通常优先使用提交读级别
>- 重复读(REPEATABLE READ)重复读出数据不会随事务提交而改变，解决重复读（MySQL默认隔离级别）
>- 可串行化(Serializable)，进行锁表操作，解决幻读
4. 数据库三大范式
>- 字段原子性，不可分割，数据库表中的所有字段都只具有单一属性
>- 有唯一主键
>- 除却主键不包含关联数据的其他字段，为了快速查询数据，也会存在反范式结构
5. mysql数据库索引的工作机制是什么
> mysql索引实现通常用B树及B+树，`B+树是脱胎于平衡二叉树的多路搜索树`，在节点空间大小
> 一定的情况下，每个节点可以存储更多的内结点
>- `所有数据存储在叶子节点上`
>- `所有叶子节点由指针连接`
6. 索引的优化
>- 尽量全值匹配索引
>- 最佳左前缀匹配法则
>- 不再索引列上做操作，减少索引表的变更
>- 范围条件放在最后，会影响前面条件，导致索引失效
>- 使用覆盖索引，减少select *
>- 不等于要慎用，not/null,使用覆盖索引
>- 字段非空，is null  会导致索引失效，字段可为空则不会
>- like要注意，左匹配不会失效
>- 字符类型+引号，防止类型不一致索引失效同时减少转换
>- or 改union
7. mysql 优化实践方式
>- 通过explain分析执行计划，优化查询
>- 常用搜索字段建立索引
>- 查询单行添加limit 1，可以有效停止多余搜索
>- 有限且固定长度的字段用enum替换varchar
>- 避免 SELECT *
>- 永远为每张表设置一个 ID
>- 所有字段为固定长度的的表会更快，
>- 垂直分割把一张大表变为多张小表
>- 拆分大的 DELETE 或 INSERT 语句
>- 越小的列会越快
>- 选择正确的存储引擎
8. mysql 锁
>- 表级锁，开销小，加锁快；不会出现死锁；锁定粒度大，
>发生锁冲突的概率最高,并发度最低。
>- 行级锁，Innodb独有，只有在对存在索引的操作才会使用行级锁，
>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。
9. timestamp 与 datetime 区别
>- timestamp,有时区，4字节，只能存1970~2037
>- datetime，无时区，8字节，1000~9999
