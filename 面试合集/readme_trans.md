#### 数据库事物
>ACID
>+ 原子性，每一个操作都是原子操作
>+ 隔离性(isolation)
```mysql
show variable like '%transaction_isolation%' ;
set session transaction isolation level read uncommit ;
```

1. 未提交读(READ-UNCOMMITED)
2. 提交读(READ-COMMITED),解决脏读,优先
3. 可重复读(REPEATABLE-READ)解决不可重复读
4. 串行读(SERIALIZABLE)解决幻读，锁表
>+ 一致性
>+ 持久性

#### 锁的本质
>- 锁要解决的问题是 ------- 资源数据会不一致
>- 锁要达成的目标是 ------- 让资源使用起来，像原子性一样
>- 锁达成目标的手段 ------- 让使用者访问资源时，只能排队，一个一个地去访问资源
#### 分布式环境下，如何协调资源达到原子性的操作？
1. sychronized / lock 这些java天然的实现，无法跨JVM发挥作用
2. 只得去寻求分布式环境里，大家都公认的服务来做见证人，以协调资源
3. 常见的公证人 ------》 mysql/zk/file/redis
4. 目标 ----- 通过公证人发出信号，来协调分布式的访问者，排队访问资源
5. 条件 ----- 任何一个能够提供【是/否】信号量的事物，都可以来做公证人
6. 陷阱 ----- 发出锁信号量的动作，本身必须是原子性的
7. mysql来充当公证人，利用的是一条sql语句执行的成功/失败，是原子的,
8. redis来充当公证人，利用的其 setnx指令的成功/失败，是原子的
> 为了防止线程宕机，造成锁死在那里挡道，需要给锁认定一个有效期限，
此期限的自动失效解锁，与线程的主动解锁之间，会存在冲突，reids的解锁流程必须考虑动作原子性，
需要改为lua脚本来执行
9. lua 脚本为什么是原子性的
> redis的worker线程是单线程执行指令的，因此内部不存在线程竞争
>- 一、服务器A依次发送了ab指令到redis
>- 二、服务器B依次发送了cd指令到redis
>- 三、两台机器同向redis发送的四条指令，最终在指令队列里顺序是：acbd
>- 四、可以看到，服务器A发送的ab两条指令，中间穿插了c指令，破坏了其完整性，因此，ab两条指令不是原子的
>- 五、lua脚本，被放进队列时，ab指令是放在一起的，因为ab会顺序一起被执行，成为了原子性动作

#### 分布式锁
通常有多个线程对一个公共资源的操作，会存在一个线程安全问题，导致公共资源最终的结果与我们的
预期不一致，而JVM为我们提供了Synchronize、Lock、ReentrantLock、ReadWriteLock以及
Atomic包下的原子属性操作 来解决线程的安全问题，但是他们解决不了跨JVM的线程安全问题，
所以就需要分布式锁来解决跨JVM的线程安全问题，首先需要考虑支持对加锁、释放锁的原子性操作，
mysql的InnoDB引擎下的行锁和唯一约束能提供一个原子操作；
zookeeper的有序临时节点操作，
redis的lua脚本，都是能够在分布式系统提供一个原子操作的，
原子操作加锁释放锁搞定后，要考虑，服务宕机，死锁不释放的问题，mysql 由于事务的回滚，
ZK临时节点在服务宕机后会删除，所以不用考虑死锁，redis需要设置超时时间来预防死锁，
但有了超时时间还需要考虑他的锁续命的问题，可以采用一个timertask来定时轮询锁是否还在
使用进行续命，原子操作、死锁问题解决后，还要考虑
锁释放怎么通知各个服务来获取锁，
mysql 由于无法提供通知，那只能服务通过休眠自旋来尝试获取，锁竞争激烈的话，对资源的消耗
可能会比较大
zk 提供了watch监听，可以随锁进行监听，当删除锁节点去尝试获取锁
redis 提供了publish和subscribe，可以对锁进行订阅，当锁释放的时候发布一个消息，通知
订阅的服务去获取锁，这样分布式锁的 原子操作加锁、死锁问题、原子操作释放锁再进行消息传递
就完成了一个闭环



>- `锁的问题是多对一的问题，是多个线程同时访问同一个资源，造成资源状态不一致`
>- `事务的问题是一对多的问题，是一个线程进数据库，操作多条sql，其中，某条sql的失败，致使整个业务失去意义`

#### 事物的操作过程
>- 编程式事务：使用 TransactionTemplate 或者直接使用底层的 TransactionManager 来操作事务 commit 或者 rollback。
>- 声明式事务：建立在 AOP 基础上，通过对方法前后进行拦截，加入编程式事务里的流程控制逻辑。使用的时候只需要在方法前
面加上@Transactional

#### BASE 理论
> 往往在分布式系统中无法实现完全一致性，于是有了 BASE 理论，它是对 CAP 定律的进一步扩充
BASE 指的是：
>- Basically Available（基本可用） ： 分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用
>- Soft state（软状态） ： 允许系统中存在中间状态，这个状态不影响系统可用性
>- Eventually consistent（最终一致性） ： 经过一段时间后，所有节点数据都将会达到一致

>BASE 和 ACID 是相反的，它完全不同于 ACID 的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时
间内是不一致的，但最终达到一致状态。
#### 分布式事物
> 分布式事务，是指多台数据库的执行sql，也想要达到一致性的标准，即：多台一起commit或rollback<br>

1. 基于可靠消息的最终一致性方案概述
> 基于XA协议的2pc,3pc,存在单点问题、同步阻塞、数据不一致
>- 3pc 在阶段三，可能会因为网络导致参与者无法收到 doCommit 请求或者 abort 请求，
针对这种情况，参与者都会在等待超时之后，继续进行事务提交
必须要使用支持XA协议的datasource数据源
>- 2pc因为要同时锁定两个数据库的数据，事务锁定时间大大延长

2. TCC事务补偿型方案
> 其将整个业务逻辑的每个分支显式的分成了 Try、Confirm、Cancel 三个操作。Try 部分完成业务的准备工作，confirm 部分完成业务的提交，cancel
部分完成事务的回滚。

![tcc 流程图](./TCC.png)

3. MQ事物
> 目前，仅阿里云的 RocketMQ 支持事务消息。帮助用户实现类似 X/Open XA 的分布事务功能，通过 MQ 事务消息能达到分布式事务的最终一致。
>- 发送方向 MQ 服务端发送消息
>- MQ Server 将消息持久化成功之后，向发送方 ACK 确认消息已经发送成功，此时消息为半消息
>- 发送方开始执行本地事务逻辑
>- 发送方根据本地事务执行结果向 MQ Server 提交二次确认（Commit 或是 Rollback），MQ Server 收到 Commit 状态则将半消息标记
为可投递，订阅方最终将收到该消息；MQ Server 收到 Rollback 状态则删除半消息，订阅方将不会接受该消息
>- 在断网或者是应用重启的特殊情况下，上述步骤 4 提交的二次确认最终未到达 MQ Server，经过固定时间后 MQ Server 将对该消息发
起消息回查
>- 发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果
>- 发送方根据检查得到的本地事务的最终状态再次提交二次确认，MQ Server 仍按照步骤 4 对半消息进行操作
4. Lcn事物
> 锁定事务单元（lock）、确认事务模块状态(confirm)、通知事务(notify)

>- TxClient 作为模块的依赖框架，提供 TX-LCN 的标准支持，
>- TxManager 作为分布式事务的控制方。事务发起方或者参与方都由TxClient 端来控制。

>- 创建事务组
>> 是指在事务发起方开始执行业务代码之前先调用 TxManager 创建事务组对象，然后拿到事务标示 GroupId 的过程。
>- 加入事务组
>> 添加事务组是指参与方在执行完业务方法以后，将该模块的事务信息通知给 TxManager 的操作。
>- 通知事务组
>> 是指在发起方执行完业务代码以后，将发起方执行结果状态通知给 TxManager,TxManager 将根据事务最终状态和事务组的信息
来通知相应的参与模块提交或回滚事务，并返回结果给事务发起方

5. Seata 事务
