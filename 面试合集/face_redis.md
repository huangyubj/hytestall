1. 什么是redis
>redis是一个基于内存操作，通过C实现的单线程key-value数据库，
>- 执行异步操作定时刷新数据到硬盘持久化，
>- 有String、Hash、List、Set、Soredset五种数据结构内容，支持超时expire设置，
>- 因为基于内存操作、单线程、C实现以及RESP协议的简单易读，是目前最快的Key-Value数据库，
受限于内存，只能试用于较小数据量的高性能操作和运算上，
>- 常用于会话缓存、排行榜计数器、队列、发布订阅。

2. redis有哪几种数据淘汰策略
>- no-enviction（驱逐）：禁止驱逐数据
>- 基于所有key的策略
>>- allkey-lru,最少使用淘汰
>>- allkey-random,随机淘汰
>- 基于设置了超时时间的策略
>>- volatile-ttl,最快要超时的淘汰
>>- volitile-lru，最少使用淘汰
>>- volitile-random，随机淘汰

3. 一个字符串最大容量
> 512M

4. redis的集群方案有哪些
>- 主从模式,
>>- 有一主一从、一主多从、星行主从等拓扑形式，主节点挂了不会自动切换主节点，不满足高可用
>>- 通过配置slaveof host:port为主节点设置一个从节点
>>- slaveof no one,脱离主节点，
>>- info replication,查看状态信息,
>- 哨兵模式(sentinel)
>>- 哨兵服务心跳检测主节点，故障时通知其他哨兵，超过半数哨兵发现故障则进行选举
```
以3个哨兵和3个redis服务为例，哨兵监听主节点，从主节点获取从节点最新信息，
通过心跳检测主节点是否正常，当一个哨兵发现主节点ping不通，会通知其他2个哨兵，
如果还有个哨兵也ping不通(设定2票为通过)则认定主节点已挂，发现的哨兵会发起选举，
经过几轮raft选举出leader，当上一个主节点恢复，则变为从节点
```

5. redis哈希槽
>- redis集群有16384个哈希槽，每个redis负责一部分的槽，不是闭环的，有利于节点的变更，增加、删除节点进行变更负责的槽位，
>- 一致性哈希算法，是一个闭合的哈希环，一个个节点分布在hash环上，依次寻找所在的位置
6. 集群选择数据库
>- 只能默认0,无法select其他数据库

7. redis管道，
> 把多次指令放入管道种一次发送，减少网络开销,需要避免一次缓存数据过大，占用尽内存，
请求不满管道需要flush进行强制发送

8. Jedis 与 Redisson 对比有什么优缺点
>- Jedis是java客户端，提供了较全面的API支持
>- Redisson实现了分布式和可扩展的 Java 数据结构,不支持字符串操作，排序、事务、管道、分区等 Redis 特性

9. redis的事物，
> redis通过MULTI开启事物，EXEC提交事物，DISCARD中断事物，WATCH监听事物，
只有在语法错误才会一次性拒绝，部分异常不会阻止其他正确指令的执行,是弱事务

10. redis内存的优化
> 减少命名长度，使用hash结构优化，减少空间占用

11. redis回收进程如何工作
> 回收进程在内存大于maxmemory的限制时，根据设置的淘汰策略进行内存的释放

12. redis分布式锁，缺点
> 利用 SETNX key value 的原子性来加锁，在利用lua脚本的原子性来释放锁<br>
> master如果宕机丢失了锁数据，会产生脏数据
>>Redlock 算法，使用redlock算法，多个redis实例,向超过半数的节点发送加锁/释放锁
指令，只有当超过半数的成功才算加锁或释放锁成功，but性能会有损失

13. 缓存击穿、缓存雪崩产生的原因和解决方案
>- 缓存穿透，查询的数据在缓存中、数据库中均没有数据，大量请求导致DB不可用,
>>- 一：可用布隆过滤器，一个bitmap用于存储可能存在的key，不存在的key直接过滤，存在一定误判率
>>- 二：获取时更新一个短时间超时的空值缓存
>- 缓存击穿是对一个缓存为空的key发送大量请求，导致db压力很大或崩溃造成缓存击穿，
通常由于热点数据失效导致的
![Dubbo 结构图](images/cache_breakdown.jpg)

>- 缓存雪崩是在同一时间大量缓存失效，涌进大量请求，导致数据库崩溃，可以采用加锁、
随机失效时间来避免同时失效来解决

14. redis和memcached
>- redis采用单线程，支持RDB和AOF持久化数据，支持多种数据结构存储，天然的支持集群、主从
>- memcached采用多线程，可缓存图片、视频，适用于纯KV，数据量大的业务

15. redis 主从复制如何实现的,redis 的集群模式如何实现?redis 的 key 是如何寻址的
>- 主从节点复制：主节点将自己内存中的数据生成一份快照发送给从节点用来恢复到内存，之后
有变更，会以二进制的形式发送给从节点执行同步
>- redis采用将hash槽分割为N个片段，每个master负责一部分槽，Master 节点维护着一个
 16384/8 字节的位序列，Master 节点用 bit 来标识对于某个槽自己是否拥有。比如：
 对于编号为 1 的槽，Master 只要判断序列的第二位(索引从 0 开始)是不是为 1 即可。
 这种结构很容易添加或者删除节点。

16. redis的持久化机制
>- RDB，通过bgsave定期存储到硬盘，耗时耗性能，数据容易丢失，恢复快，存在线程阻塞
>- AOF，存储操作指令到aof日志中，产生的体积大，恢复慢，不容易丢失数据

17. redis的过期策略，LRU算法
> 惰性过期，在使用的时候判定是否过期；定时过期，定时任务进行过期扫描<br>
> LRU最近最少使用算法

18. 缓存与数据库不一致怎么解决
> 数据库执行增删改清除缓存(mybatis的缓存即是如此处理)，从库更新数据缓存中的数据也更新

19. redis常见性能问题和解决方案
- master最好不做持久化工作
- 如果数据比较重要，在某个slave开启AOF备份，策略1s同步一次
- 为了主从复制的速度和链接的稳定,master和slave最好在一个局域网
- 尽量避免在压力大的主库上添加从库
- 主从复制，尽量使线性结构，避免节点压力大 master<-slave1<-slave2